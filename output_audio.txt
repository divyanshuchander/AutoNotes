The following content is provided under a Creative Commons license.
Your support will help MIT OpenCourseWare
continue to offer high-quality educational resources for free.
To make a donation or view additional materials from hundreds of MIT courses,
visit MIT OpenCourseWare at ocw.mit.edu.
OK.
I finished up last time talking about lists.
And I pointed out that lists are mutable.
Showed you some examples of mutation.
We can look at it here.
We looked at a pen, which added things to lists.
We looked at delete.
Deleting things from a list.
You can also assign to a list or to an element of a list.
So IV sub 1, for example, could be a sign minus 15.
And that will actually mutate the list.
So here to IV, when we wrote assignment, what we always meant was changing the binding of a variable to a different object.
Here, we are overloading the notation to say, no, no.
IVs are still bound to the same object, but an element of IVs is bound to a different object.
If you think about it, that makes sense.
Because when we have a list, what a list is is a sequence of objects.
And what this says is the object named by the expression IVs sub 1 is now bound to the object,
if you will, named by the constant minus 15.
So we can watch this run here.
I don't can.
That's exciting.
I didn't expect that answer.
All right, your question.
So if you have four horizontal and slow-spin, and you have changed a bit, oh, it's not even
a single pattern.
Well, I'll tell you how we'll, let's answer that the easy way.
We'll start up a shell and we'll try it.
All right, we'll just get out of what we were doing here.
And so we now have some things.
So we, for example, have IVs.
I can print IVs.
And it's only got three elements, but your question probably is just as good
for adding the fourth is adding the fifth.
So what would happen if we say IVs sub 3, because that, of course, is a fourth element, right?
Let's find out.
Okay, because what that does is it's changing the binding of the name IVs, in this case, sub 1.
What it looked at here with the name IV sub 3, and said that name doesn't, isn't bound, right?
Isn't there?
So it couldn't do it.
So instead, that's what append is for, is to stick things onto the end of the list.
But a very good question.
So we can see what we did here.
And, but of course, I can now, if I choose, say something like IVs sub 1 is a sign minus 5.
And now, if I print IVs, there it is.
And again, this points out something I wanted to, I mentioned last time, lists can be heterogeneous,
in the sense that the elements can be multiple different types.
As you see here, some of the elements are screens and some of the elements are integers.
Let's look at another example.
Let's suppose we'll start with the list.
I'll call it L1.
This, by the way, is a really bad thing I just did.
What's really bad about calling the list L1?
Is it L1 or is it 11 or is it LL?
It's a bad habit to get into when you write programs.
So I never use lowercase L, except when I'm spelling a word, where it's obvious.
Because otherwise, I get ulcerates of crazy things going on.
All right, so let's make it the list 1, 2, 3.
All right.
Now, I'll say L2 equals L1.
Now, I'll print L2, kind of what you guessed.
But here's the interesting question.
If I say L1 is assigned L1 sub 0 is assigned 4.
Now, I'll print L1.
That's what you'd expect.
But what's going to happen if I print L2?
4, 2, 3 as well.
And that's because what happened is I had this model, which we looked at last time, where I had the list L1,
which was bound to an object.
And then the assignment L2 gets L1 bound the name L2 to the same object.
So when I mutated this object, which I reached through the name L1, to make that 4,
since this name was bound to the same object when I print it, I got 4, 2, 3.
So that's a key thing to realize that what the assignment did was have two separate paths to the same object.
So I could get to that object either through this path or through that path.
It didn't matter which path I used to modify it.
I would see it when I looked at the other.
Yes.
So the question if I said A is assigned 2, B is assigned A, and then A is assigned 3.
Is that that's your question?
So the question is A is assigned 1, B is assigned A, A is assigned 2, and then if I print B, I'll get 1.
Because these are not mutable, this is going to be assigned 2, and object in the store.
So we'll draw the picture over here, that we had initially A is bound to an object with 1 in it.
And then B got bound to the same object.
But then when I did the assignment, what that did was it broke this connection, and now had A assigned to a different object with the number in this case 2 in it.
Whereas the list assignment you see here did not re-bind the object L1.
It changed this.
Okay?
Now, formally I could have had this pointing off to another object containing 4, but that just seemed excessive.
But you see the difference? Great question.
And a very important thing to understand, and that's why I'm belaboring this point.
Since this is where people tend to get pretty confused, and this is why mutation is very important to understand.
Yeah?
I'm just assuming it'll be a great question.
If you would see it on L1, then L1 would be a good question.
Exactly.
So if very good question.
So for example, we can just do it here.
The question was suppose I now type L1 equals the empty list.
I can print L1, and I can print L2, because again, that's analogous to this example, where I just swung the binding of the identifier.
So this is important. It's a little bit subtle, but if you don't really understand this deeply, you'll find yourself getting confused a lot.
All right. Okay. Let me move on.
And I want to talk about one more type.
By the way, if you look at the handout from last time, you'll see that there are some other examples of mutation, including a function that does mutation.
It's kind of interesting, but I don't think we need to think we've probably done enough here that I hope it now makes sense.
The one type I want to talk about still is dictionaries.
Like lists, dictionaries are mutable.
Like lists, they can be heterogeneous. But unlike lists, they are not ordered.
The elements in them don't have an order. And furthermore, we have generalized the indexing.
So lists and strings, we can only get it elements by numbers, by integers, really.
Here, what we use is think of every element of the dictionary as a key value pair,
where the keys are used as the indices. So we can have an example. Let's look at it.
So if you look at the function show decks here, you'll see the clearer variable called E to F, think of that as English to French.
And I've defined the dictionary to do translations. And so we see that the string 1 corresponds the key 1 corresponds to the value A, the key soccer corresponds to the French word football, et cetera.
It's kind of bizarre, but the French call soccer football. And then I can index in it. So if I print E to F of soccer, it will print the string football.
So you can imagine that this is a very powerful mechanism.
So let's look what happens when I run start to run this.
All right. So it says not defined and why did it say not defined as an interesting question. Let's just make sure we get this right.
We'll start the shell up again.
All right. So I run it and sure enough it shows football. What happens if I go E to F of zero?
I get a clearer because remember these things are not ordered. There is no zero element.
Zero is not a key of this particular object. Now I could have made zero a key. Key's don't have to be strings, but as it happened I didn't.
Let's comment that out so we don't get stuck again.
Where we were before. I've printed it here. You might be a little surprised of the order. Why is soccer first?
Because the order of this doesn't matter. That's why it's using set braces. So don't worry about that.
The next thing I'm doing is so that's that. And then I'm now going to create another one.
And to S for numbers to strings where my keys are numbers. In this case the number one corresponds to the word one.
And interestingly enough, I'm also going to have the word one corresponding to the number one. I use anything I want for keys. I can use anything I want for values.
And now if we look at this we see I can get this. All right. So these are extremely valuable. I can do lots of things with these and you'll see that as we get to future assignments will make heavy use dictionaries.
You can, but you don't know what order you'll get them in. What you can do is you can iterate keys, which gives you the keys in the dictionary.
And then you can choose them, but there's no guarantee in the order in which you get keys.
Now you might wonder why do we have dictionaries. It would be pretty easy to implement them with lists.
Because you could have a list where each element of the list was a key value pair.
And if I wanted to find a value corresponding to a key, I could say for E in the list if the first element of E is the key, then I get the value otherwise I look at the next element in the list.
So adding dictionaries as Professor Grimson said with so many other things doesn't give you any more computational power.
It gives you a lot of expressive convenience. You can write the programs much more cleanly, but most importantly it's fast.
Because if you did what I suggested with the list, the time to look up a key would be linear in the length of the list. You have to look at each element until you found the key.
Dictionaries are implemented using a magic technique called hashing, which we'll look at a little bit later in the term, which allows us to retrieve keys in constant time.
But it doesn't matter how big the dictionary is, you can instantaneously retrieve the value associated with the key.
Extremely powerful, not in the next problem set, but in the problem set after that, we'll be exploiting that facility of dictionaries.
All right, any questions about this? If not, I will turn the podium over to Professor Grimson.
Having stolen the key.
Let me tell you the two things I want to do. I want to talk a little bit about how you use the things we've been building in terms of functions to help you structure an organizer code.
It's a valuable tool that you want to have as a programmer.
And then we're going to turn to the question of efficiency. How do we measure efficiency of algorithms? It's going to be a really important thing that we want to deal with.
And we'll start at the day as I'm going to take a couple of more lectures to finish it off.
Right, so how do you use the idea of functions to organize code? We've been doing it implicitly. Ever since we introduced functions, I want to make it a little more explicit.
And I want to show you a tool for doing that. I think the easy way to do it is to do it with an example. So let's take a really simple example.
I want to compute the length of the hypotenuse of a right triangle. And yeah, I know you know how to do it. But let's think about what might happen if I wanted to do that.
In a particular, if I think about that problem, actually, I want to do this.
If I think about that problem, I'm going to write a little piece of pseudo code.
Now, you're all linguistic majors, pseudo means false. This sounds like code that ain't going to run. And that's not the intent of the term. When I say pseudo code, what I mean is I'm going to write a description of the steps, but not in a particular programming language. I want to simply write a description of what I want to do.
So if I were to solve this problem, here's the way I would do it. I would say first thing I want to do. So I want to input value for the base.
As a float, need to get the base in.
Second thing I want to do, I need to get the height. So I'm going to input value for the height, also as a float, a floating point.
Okay, I get the two values in. What do I need to do? Well, you sort of know that, right? I want to then do. I need to find the square root.
B squared plus h squared, right? The base, plus the height. That's the thing I want for the high pottenuus.
And I'm going to save that as a float in height for high pottenuus.
And then finally I need to print something out. Using the value in height.
Okay, what do you do, right? Come on, we know how to do this. But notice what I did. First of all, I've used the notion of modularity. I've listed a sequence of modules, the things that I want to do.
Second thing to notice is that little piece of pseudo code is telling me things about values. I need to have a float. I need to have another float here. It's giving me some information.
Third thing to notice is there's a flow of control. The order in which these things are going to happen. And the fourth thing to notice is I've used abstraction.
I've said nothing about how I'm going to make square root. I'm using it as an abstraction saying I'm going to have square root from somewhere. Maybe I'll build it myself. Maybe somebody gives it the two of me as part of a library. So I'm burying the details inside of it.
I know this is a simple example, but when you mature as a programmer, one of the first things you should do when you sit down to tackle some problem is write something like the pseudo code.
I know Professor Goodtag does it all the time. I know for a lot of you it's like, okay, I got a hard, I have a problem. Let's see D E F, Fubar, open print, a bunch of parameters.
Wrong way to start. Start by thinking what what are the sequences. This also by the way in some sense gives me the beginnings of my comments for what the structure my code is going to be.
Okay, if we do that and if you look at the handout then I can now start implementing this. I want to just show you that. So first thing I'm going to do is say, all right, I know I'm going to need square root in here. So I'm going to in fact import math.
And that's a little different from other import statements. This says I'm going to get the entire math library and bring it in so I can use it.
And then what's the first thing I wanted to do? I need to get a value for base as a float. Well, okay, that's how I'm going to need to do input of something.
And you can see that statement there. It's got the wrong glasses on, but right there I'm going to do an input with a little message and I'm going to store it in base.
But here's where I'm going to practice a little bit of defensive programming.
I can't rely on Professor Goetheg, if I give this code to him, I can't rely on him to type in a float. Actually, I can't because he's a smart guy, but in general, I can't rely on the user.
Actually, he's right, you know, he would not do a just to see if I'm doing it right. I can't rely on the user. I want to make sure I get a float in it. So how do I do that? Well, here's one nice little trick.
First of all, having read in that value, I can check to see is it of the right type. Now, this is not the nicest way to do it.
But it'll work. I can look at the type of the value of base and compare it to the type of an actual float and see are they the same. Is this a real or a float?
If it is, I'm done. How do I go back if it isn't? Well, I'm going to create a little infinite loop, not normally a good idea.
I set up a variable here called input okay, initially it's false because I have no input.
And then I run a loop in which I read something in, I check to see if it's the right type if it is. I change that variable to say it's now the correct type,
which means the next time through the loop, I'm going to say I'm all set and I'm going to bounce out.
But if it is not, it's going to print out a message here saying you screwed up somewhat lightly and it's going to go back around.
So, I'm going to go back to the right type, and I'm going to go back to the right type.
Nice way of doing it. Right, what's the second thing I do? Well, I get the same sort of thing to read in the height.
Once I have that, I'm going to take base squared plus height squared and there's a form that we just seen once before and it's going to repeat it.
That is math dot squirt and it says the following. It says, take from the math library.
I'm going to call squirt. We're going to come back to this when we get to objects. It's basically picking up that object and it's applying that.
Putting that value into height and then just printing something out.
And again, if I just run this just to show that it's going to do the right thing.
It says enter base. I'm obnoxious. It says, oops, wasn't a float. So, we'll be nice about it.
And I enter a height. And I print out what I expected. I just concatenated those strings together by the way at the end.
All right, notice what I did. Okay? I went from this description. It gives me sense of information.
I need to have a particular type. I made sure I had that particular type. I've used some abstraction to suppress some details here.
Now, if you look at that list, there's actually something I didn't seem to check, which is I said, I wanted a float stored in height.
How do I know I've got a float in height? Well, I'm relying on the contract, if you like, the manufacturer of square root put together, which is if I know I'm giving it two floats, which I do, because I make sure they're floats.
The contract, if you like, of square root says, I'll give you back a float. So, I can guarantee I've got something of the right type.
Okay, I know this is boring as whatever, but there's an important point here.
Having now used this pseudocode to line things up, I can start putting some additional structure on this. In a particular, I'm sure you're looking at this going,
well, look at that if we look at the right piece, going, wait a minute.
This chunk of code and this chunk of code, they're really doing the same thing.
And this is something I want to use. If I look at those two pieces of computation, I can see a pattern there.
It's an obvious pattern of what I'm doing. And in particular, I can then ask the following question, which is what's different between those two pieces of code.
And that's the just two things, right? One is, what's the thing I print out when I ask for the input?
The second thing is, what do I print out if I actually don't get the right input in?
So, the only two differences are right there and there versus here and here.
So, this is a good place to think about, okay, let me capture that.
Let me write a function. In fact, the literal thing I would do is to say identify the things that change.
Give each of them a variable name because I want to refer to them.
And then write a function that captures the rest of that computation just with those variable names inside.
And in fact, if you look down and I'm just going to highlight this portion, I'm not going to run it, but if you look down here,
it's exactly what that does. I haven't had a comment to do, right? What does it do?
It has, I've got two names of things. The request message and the error message.
The body of that function looks exactly like the computation of a Bob, except I'm simply using those in place of the specific message I had before.
And then the only other differences obviously is a function I need to return a value.
So, when I'm done, I'm going to give the value back out.
All right? And that then lets me get to, basically this code.
Having done that, I simply call base with get float. I call height with get float.
I do the rest of the work.
All right. What's the point of doing this?
Well, notice again, what I've done, I've captured a module inside of a function.
And even though it's a simple little thing here, there's a couple of really nice advantages to this.
All right. First one is there's less code to read. It's easier to debug. I don't have as much to deal with.
But the more important thing is, I've now separated out implementation from functionality or implementation from use.
What does that mean? It means anybody using that little function get float.
Doesn't have to worry about what's inside of it. So, for example, I decided I want to change the message I print out.
I don't have to change the function. I just pass in a different parameter.
If I, you know, sorry, let me say a different. I don't need to worry about how checking is done.
It's handled inside of that function.
If I decide there's a better way to get input and there is, then I can make a change,
but I don't have to change the code that uses the input.
So, if you like, I've built a separation between the user and the implementer.
And that's exactly one of the reasons why I want to have the functions.
I've separated those out. Another way of saying it is anything that uses get float.
Doesn't care what the details are inside or shouldn't. If I change that definition, I don't have to change anything else where in my code.
Whereas if I just have the raw code and there I have to go off and do it.
So, the things we want you to take away from this are, get into the habit of using pseudo code.
When you sit down to start a problem, write out what are the steps.
And we'll tell you that a good programmer, at least in my mind, may actually go back and modify the pseudo code,
as they realize they're missing things, but it's easier to do that when you're looking at a simple set steps than when you're in the middle of a pile of code.
And get into the habit of using it to help you define what is the flow of control.
What are the basic modules? What information needs to be passed between those modules in order to make the code work?
Okay, that was the short topic.
We'll come back to this one more and you're going to get lots of practice with this.
What I want to do is to start talking about a different topic, which is efficiency.
And this is going to sound like a weird topic. We're going to see why it's a value.
A second.
I want to talk about efficiency.
And we're going to, at least I'm going to, at times, also refer to this as orders of growth for reasons that you'll see over the next few minutes.
Now, efficiency is obviously an important consideration when you're designing code.
Although I have to admit, at least for me, I usually want to at least start initially with code that works.
And then worry about how I might go back and come up with more efficient implementations.
I like to have something I can rely on, but it is an important issue.
In our goal, over the next couple of lectures, this is basically to give you a sense of this.
So we're not going to turn you into an expert on computational efficiency.
That's their whole course is on that. There's some great courses here on that.
There's some mathematical sophistication. We're going to push that off a little bit.
But what we do want to do is to give you some intuition about how to approach questions of efficiency.
We want you to have a sense of why some programs complete almost before you're done typing it.
Some programs run overnight.
Some programs won't stop until I'm old and gray.
Some programs won't stop until you're old and gray.
And these are really different efficiencies. We want to give you a sense of how do you reason about those different kinds of programs.
And part of it is we want you to learn how to have a catalog if you like a different classes of algorithms.
So that when you get a problem, you try and map it into an appropriate class and use the leverage if you like of that class of algorithms.
Now, it's a quick sidebar. I've got to say I'm sure talking about efficiency folks like you probably seems really strange.
I mean, you grew up in an age when computers are blazingly fast and have tons of memories. So why in the world do you care about efficiency?
Some of us, we're not so lucky. So I'll admit my first computer I program was a PDP6.
Only Professor Goodtag even knows what PDP stands for. It was made by digital equipment company, which does not exist anymore.
It's not long gone. It had, I know this is old guy stories, but it had 160K of memory.
Yeah, 160K, 160 kilobits of memory. I mean, your flashcards have more than that, right?
It had a processor speed of one megahertz. You did a million operations per second.
So let's think about it. This sucker, what's it got in there? That air-mac, it's C. It's got a higher mac, I don't know about John's.
His is probably better. Mine has 1.8 gigahertz speed. It's 1,800 times faster.
But the real one that blows me away is it has two gig of memory inside of it. That's 12,000 times more memory.
Oh, and by the way, the PDP6, it was in a rack about this tall, from the floor, not from the table.
All right, so you didn't grow up in the late 1800s like I did. You don't have to worry about this sort of stuff, right?
But I point I'm trying to make, as it sounds like you know computers are gotten so blazingly fast. Why should you worry about it?
Let me give you one other anecdote that I can't resist. This is the kind of thing you can use at cocktail parties to impress your friends from Harvard.
Imagine I have a little lamp, little goose necklamps, I put it on the table here, I put the height about a foot off the table.
And if I was really good, I could hit our time so that when I hurt, yeah, try again.
When I turned this on switch on on the lamp, at exactly the same time, I'm going to hit a key on my computer and start it running.
Okay? In the length of time, it takes for the light to get from that bulb to the table.
This machine processes two operations.
Oh, come on, that's amazing. Two operations, now you can do the simple numbers, right?
A light travels basically a foot in a nanosecond, simple rule of thumb.
A nanosecond is what? 10 to the minus 9 seconds. This thing does two gig worth of operations.
A gig is 10 to the minus, so it does two operations. Then like the time it takes light to get from one foot off the table down to the table. That's amazing.
So why in the world do you care about efficiency? Well, the problem is that the problems grow faster than the computers speed up.
Keep you two examples. I happen to work in medical imaging, actually so does Professor Goodtag.
In my area of research, it's common for us to want to process about 100 images a second in order to get real time display.
Each image has about a million elements in it. I got a process about a half a gig of data a second in order to get anything out of it.
Second example, maybe one that'll hit a little more home to you. I'm sure you all use Google. I'm sure it's a verb in your vocabulary, right?
Google processes 10 million pages. I think 10 billion was the last number I heard. That's on about right?
Maybe more by now. But let's forsake of argument 10 billion pages. Imagine you want to search through Google to find a particular page.
You want to do it in a second and you're going to just do it the brute force way. Assume you could even reach all those pages in that time.
You're going to do that. You've got to be able to find what you're looking for in a page in two steps where a step is a comparison or an arithmetic operation.
And going to happen. You just can't do it. Again, part of the point here is that things grow or the refraiser that interesting things grow at an incredible rate.
As a consequence, brute force methods are typically not going to work.
Okay, so that then leads to the question of what should we do about this? And probably the obvious thing you'll think about is, well, come up with a clever algorithm.
And I want to disobuse you of that notion. It's a great idea if you can do it.
The guy who, I think I'm going to say this right, John, right? Sanjay, Kimmer Wat.
With the guy who is a graduate of art department who is the heart and soul behind Google's really fast search is an incredibly smart guy.
And he did come up with a really clever algorithm about how you structure that search in order to make it happen.
And he probably made a lot of money along the way. So if you have a great idea, you know, talk to good pat in attorney and get it locked away.
But in general, it's hard to come up with the really clever algorithm.
But your much better at doing is saying, how do I take problem I've got and map it into a class of algorithms about which I know and use the efficiencies of those to try and figure out how to make it work.
So what we want to do is, I guess another way of saying it is efficiency is really about choice of algorithm.
And we want to help you learn how to map a problem into a class of algorithms of some efficiency.
That's our goal.
Okay, so to do this, we need a little more abstract way of talking about efficiency. And so the question is, how do we think about efficiency?
And typically there's two things we want to measure space and time.
Sounds like an astrophysics course, right?
Now space usually we try it again. When we talk about space, what we usually refer to is how much computer memory does it take to complete a computation of a particular size.
Right, so let me write that down.
How much memory do I need to complete a computation? And by that, I mean not how much memory do I need to store the size of the input is really how much internal memory do I use up as I go through the computation.
I've got some internal variables I have to store. What kinds of things do I have to keep track of?
You're going to see the arguments about space if you take some of the courses at follow one and there's again some nice courses about that. For this course, we're not going to worry about space that much. What we're really going to focus on is time.
Okay, so we're going to focus here.
And the obvious question I could start with is, you suppose I ask you how long does the algorithm implemented by this program take to run?
How much I answer that question? Any thoughts?
Yep.
Ah, your jumping ahead of me. Great. The answer was find a mathematical expression depending on the number of inputs and exactly where I want to go.
Thank you. I was hoping for a simpler answer which is just run it.
Which is, yeah, I know. Seems like a dumb thing to say, right? One of the things you can imagine is just try it on an input. See how long it takes.
You're all clever than that, but I want to point out why that's not a great idea. First of all, it depends on which input I picked.
Obviously, the algorithm is likely to depend on the size of the input, so this is not a great idea.
Second one is the depends on which machine I'm running on.
If I'm using a PDP6, it's going to take a whole lot longer than if I'm using an air Mac.
Third one is, it may depend on which version of Python I'm running.
Depends on how clever the implementer of Python was.
Fourth one is it may depend on which programming language I'm doing it in.
So I could do it empirically, but I don't want to do that typically. It's just not a great way to get out of.
And so, in fact, what we want is exactly what the young lady said.
I'm going to ask the following question which is, let me write it down.
What is the number of basic steps needed as a function of the input size?
That's the question we're going to try and address.
If we can do this, this is good because first of all, it removes any questions about what machine I'm running on.
It's talking about fundamentally how hard is this problem.
And the second thing is, it is going to do it specifically in terms of the input, which is one of the things that I was worried about.
Okay, so to do this, we're going to have to do a couple of things.
The first one is, what do we mean about input size?
And unfortunately, this depends on the problem.
It could be what the size of the integer I pass in is an argument.
If that's what I'm passing in, it could be how long is the list if I'm processing a list or a two-poly.
It could be how many bits are there in something.
So that is something where we have to simply be clear about specifying what we're using as input size.
And we want to characterize it mathematically as some number or some variable route.
The length of the list, the size of the integer would be the thing we want to do.
The second thing we've got to worry about is, what's a basic step?
Right, if I bury a whole lot of computation inside of something, I say, wow, this program runs in one step.
Unfortunately, that one step calls the Oracle a Delphi and gets an answer back.
Maybe not quite what you want.
We're typically going to use as basic steps the built-in primitives that a machine comes with.
We're in other ways saying it is we're going to use as the basic steps, those operations that run in constant times.
So arithmetic operations, comparisons, memory access.
And in fact, one of the things we're going to do here is we're going to assume particular model,
called a random access model, which basically says, we're going to assume that the length of time it takes
me to get to any location in memory is constant.
It's not true, by the way, of all programming languages.
In fact, Professor Goodtack already talked about that in some languages lists take a time linear with the length to get to it.
So we're just assuming we can get to any piece of data, any instruction in constant time.
And the second assumption we're going to make is that the basic primitive steps take constant time, same amount of time to compute.
Again, not completely true, but it's a good model. So arithmetic operations, comparisons, things of that.
So we're all going to assume we're basically in that particular model.
Okay, having done that, then there are three things that we're going to look at.
As I said, what we want to do is we want to count the number of basic steps it takes to compute a computation as a function of input size.
And the question is, what do we want to count?
Now one possibility is to do best case.
Overall, possible inputs to this function, what's the fastest it runs?
The fewest, most of the minimum if you like.
It's nice, but not particularly helpful. The other obvious one to do will be worst case.
Again, overall possible inputs to this function, what's the most number of steps it takes to do the computation.
And the third possibility is to do the expected case.
The average, if you want to think of it that way.
In general, people focus on worst case for a couple of reasons.
In some ways, this would be nicer to expect a case.
It's going to tell you on average how much you expect to take.
But it tends to be hard to compute because to compute that, you have to know a distribution on inputs.
How likely are all the inputs? Are they all equally likely?
Or are they going to depend on other things?
That may depend on the user. So you tend to get at that.
Whereas a consequence is going to focus on worst case.
This is handy for a couple of reasons.
One, it means there are no surprises.
If you run it, you have a sense of the upper bound about how much time it's going to take to do this computation.
So you're not going to get surprised by something showing up.
The second one is, a lot of the time, the worst case is the one that happens.
Professor Goetheck, use the example of looking in a dictionary for something.
Now imagine that dictionary actually has something that's a linear search to go through it as opposed to the hashing he did.
So it's a list for example.
If it's in there, you'll find it. Perhaps very quickly.
If it's not there, you've got to go through everything to say it's not there.
And so the worst case often is the one that shows up, especially in things like search.
So as a consequence, we're going to stick with the worst case analysis.
Now I've got two minutes left.
I was going to start showing you some examples, but I think rather than doing that,
I'm going to stop here.
We'll give you two minutes back of time, but I want to just point out to you that we are going to have fun next week.
Because I'm going to show you what in the world that has to do with efficiency.
So with that we'll see you next time.
